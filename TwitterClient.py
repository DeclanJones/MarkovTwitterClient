import tweepy
import datetime
import re

TWEET_SCRAPE_ARCHIVE_PATH = '/Users/declanjones/Desktop/TweetProj/Tweet_Data/Corpus/'

class TwitterClient:
    'Class to GET and POST Tweets generated by Markov Chains'

    def __init__(self, CONSUMER_KEY, CONSUMER_SECRET, ACCESS_TOKEN, ACCESS_TOKEN_SECRET):
        self.CONSUMER_KEY = CONSUMER_KEY
        self.CONSUMER_SECRET = CONSUMER_SECRET
        self.ACCESS_TOKEN = ACCESS_TOKEN
        self.ACCESS_TOKEN_SECRET = ACCESS_TOKEN_SECRET
        self.AUTH = tweepy.OAuthHandler(self.CONSUMER_KEY, self.CONSUMER_SECRET)
        self.AUTH.set_access_token(self.ACCESS_TOKEN, self.ACCESS_TOKEN_SECRET)
        self.API = tweepy.API(self.AUTH)
        self.ME = self.API.me()

    # Method for posting tweets
    def post(self, string):
        try:
            self.API.update_status(string)
        except tweepy.TweepError:
            print 'Posting Error for user: ' + self.ME.screen_name
            return False
        return True

    # Scrape numTweets from a user to populate .txt file
    def scrape(self, numTweets=100, userName='TheTweetOfGod'):
        # Remove links using regular expression matching
        pattern = re.compile('http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+')

        # Attempt scrape
        try:
            user = self.API.get_user(userName)
            tweetLst = self.API.user_timeline(user.id, count=numTweets)
        except tweepy.TweepError:
            print 'Could not scrape {0} tweets from user: {1}'.format(numTweets, userName)
            return False

        # Get Tweet Metadata
        date_obj = datetime.date.today() - datetime.timedelta(hours=5) # set cutoff 5 hours earlier
        dateCutoff = datetime.datetime.strptime(date_obj.strftime("%Y-%m-%d_%H:%M:%S"), "%Y-%m-%d_%H:%M:%S")
        today = datetime.datetime.utcnow()
        file = TWEET_SCRAPE_ARCHIVE_PATH + '{0}_{1}.txt'.format(userName, today)

        # Record Tweets in file
        if len(tweetLst) > 0:
            f = open(file, 'wb')
            for tweet in tweetLst:
                if tweet.created_at > dateCutoff:
                    tweet = str(tweet.text.encode("utf-8"))
                    tweet = pattern.sub('', tweet)
                    f.write(tweet + '\n')
                else: #We have already recorded this tweet
                    pass
            f.close()
        return True
